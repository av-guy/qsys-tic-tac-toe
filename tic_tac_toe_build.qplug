---@diagnostic disable: undefined-global, cast-local-type

PluginInfo = {
  Name = "Tic-Tac-Toe",
  Version = "0.1",
  BuildVersion = "2.0.1.3",
  Id = "156af925-61ad-48ed-be9d-72744b021415",
  Author = "Jonathan C",
  Description = "A tic-tac-toe game you can play with your friends in Q-SYS",
}

function GetColor(props)
  return { 102, 102, 102 }
end

function GetPrettyName(props)
  return "Tic-Tac-Toe\nVersion " .. PluginInfo.Version
end

function GetProperties()
  local props = {}
  return props
end

function RectifyProperties(props)
  return props
end

function GetControls(props)
  local ctrls = {}
  for row = 0, 2 do
    for col = 0, 2 do
      local name = string.format("Cell%d%d", row, col)
      table.insert(ctrls, {
        Name = name,
        ControlType = "Button",
        ButtonType = "Momentary",
        PinStyle = "Input",
        UserPin = true
      })
    end
  end

  table.insert(ctrls, {
    Name = "TicTacToe",
    ControlType = "Indicator",
    IndicatorType = "Text",
    UserPin = false
  })

  table.insert(ctrls, {
    Name = "OnePlayer",
    ControlType = "Button",
    ButtonType = "Toggle",
    PinStyle = "Input",
    UserPin = true
  })

  table.insert(ctrls, {
    Name = "TwoPlayer",
    ControlType = "Button",
    ButtonType = "Toggle",
    PinStyle = "Input",
    UserPin = true
  })

  table.insert(ctrls, {
    Name = "StartGame",
    ControlType = "Button",
    ButtonType = "Momentary",
    PinStyle = "Input",
    UserPin = true
  })

  return ctrls
end

function CreateTicTacToeLayout(props)
  local layout = {}
  local graphics = {}

  local cellSize = { 50, 50 }
  local cellGap = 5
  local boardX = 20
  local boardY = 20

  for row = 0, 2 do
    for col = 0, 2 do
      local name = string.format("Cell%d%d", row, col)
      local additionalYMargin = 20

      layout[name] = {
        PrettyName = "Cell" .. row .. col,
        FontSize = 24,
        Style = "Button",
        Position = { boardX + col * (cellSize[1] + cellGap),
          boardY + additionalYMargin + row * (cellSize[2] + cellGap) },
        Size = cellSize
      }
    end
  end

  local modeX = boardX + 3 * (cellSize[1] + cellGap) + 30
  local modeY = boardY
  local yMargin = 20
  local modeW = 100
  local modeH = 30
  local modeGap = 10

  layout["OnePlayer"] = {
    PrettyName = "1 Player",
    Legend = "1 Player",
    FontSize = 12,
    Style = "Button",
    Position = { modeX, modeY + yMargin },
    Size = { modeW, modeH }
  }

  layout["TwoPlayer"] = {
    PrettyName = "2 Players",
    Legend = "2 Players",
    FontSize = 12,
    Style = "Button",
    Position = { modeX, modeY + modeH + modeGap + yMargin },
    Size = { modeW, modeH }
  }

  layout["GameStatus"] = {
    PrettyName = "Game Status",
    Style = "Text",
    FontSize = 10,
    Position = { 250, 70 },
    Size = { 140, 20 }
  }

  layout["StartGame"] = {
    PrettyName = "Start Game",
    Legend = "Start",
    FontSize = 12,
    Style = "Button",
    Position = { modeX,
      modeY + 2 * (modeH + modeGap) + cellSize[1] + cellGap + 15 },
    Size = { modeW, modeH }
  }

  layout["TicTacToe"] = {
    PrettyName = "Tic-Tac-Toe",
    Position = { boardX + 3, boardY - 15 },
    Size = { (50 * 3 + 5 * 3) - 10, 20 },
    FontSize = 14,
    HTextAlign = "Center",
    StrokeColor = { 102, 102, 102, 0 },
    Color = { 102, 102, 102 },
  }

  table.insert(graphics, {
    Type = "Text",
    Text = "Mode",
    Position = { modeX, modeY - 15 },
    Size = { 80, 20 },
    FontSize = 14,
    HTextAlign = "Left"
  })

  return layout, graphics
end

function GetControlLayout(props)
  local layout, graphics = CreateTicTacToeLayout(props)
  return layout, graphics
end

---@diagnostic disable: undefined-global

local PLAYER = "X"
local SIZE = 3
local MODE = nil
local EMPTY = ""
local GAME_STATUS = "initialized"
local MAX_PLAYER = "X"
local MIN_PLAYER = "O"

local BOARD = {
  { EMPTY, EMPTY, EMPTY },
  { EMPTY, EMPTY, EMPTY },
  { EMPTY, EMPTY, EMPTY }
}

local function indexToRowCol(idx, size)
  local zeroBased = idx - 1
  local row = math.floor(zeroBased / size) + 1
  local col = (zeroBased % size) + 1
  return row, col
end

local function rowColToIndex(row, col, size)
  local zeroBased = (row - 1) * size + (col - 1)
  return zeroBased + 1
end

local function resetBoard()
  return {
    { EMPTY, EMPTY, EMPTY },
    { EMPTY, EMPTY, EMPTY },
    { EMPTY, EMPTY, EMPTY }
  }
end

local function checkWin(board, size)
  for i = 1, size do
    if board[i][1] ~= EMPTY and board[i][1] == board[i][2] and board[i][2] == board[i][3] then
      return board[i][1]
    end
    if board[1][i] ~= EMPTY and board[1][i] == board[2][i] and board[2][i] == board[3][i] then
      return board[1][i]
    end
  end

  if board[1][1] ~= EMPTY and board[1][1] == board[2][2] and board[2][2] == board[3][3] then
    return board[1][1]
  end

  if board[1][3] ~= EMPTY and board[1][3] == board[2][2] and board[2][2] == board[3][1] then
    return board[1][3]
  end

  for i = 1, size do
    for j = 1, size do
      if board[i][j] == EMPTY then
        return "ongoing"
      end
    end
  end

  return "draw"
end

local function drawBoardState(boardPieces)
  for i, row in ipairs(BOARD) do
    for j, cell in ipairs(row) do
      local idx = rowColToIndex(i, j, SIZE)
      boardPieces[idx].Legend = cell or ""
    end
  end
end

local function availableMoves(board, size)
  local moves = {}

  for r = 1, size do
    for c = 1, size do
      if board[r][c] == EMPTY then
        table.insert(moves, { r, c })
      end
    end
  end
  return moves
end

local function utility(terminalResult, depth)
  if terminalResult == MAX_PLAYER then
    return 10 - depth
  elseif terminalResult == MIN_PLAYER then
    return depth - 10
  else
    return 0
  end
end

local function minimax(board, depth, maximizing, alpha, beta, size, playAsMinimizer)
  -- 1️⃣  Terminal test
  local terminal = checkWin(board, size)
  if terminal ~= nil or #availableMoves(board, size) == 0 then
    return utility(terminal, depth)
  end

  -- 2️⃣  Initialise best value for this node
  local best = maximizing and -1000 or 1000

  -- 3️⃣  Explore every legal move
  for _, move in ipairs(availableMoves(board, size)) do
    local r, c = move[1], move[2]
    local piece

    if maximizing then
      piece = playAsMinimizer and MIN_PLAYER or MAX_PLAYER
    else
      piece = playAsMinimizer and MAX_PLAYER or MIN_PLAYER
    end

    board[r][c] = piece
    local val = minimax(board, depth + 1,
      not maximizing,
      alpha, beta, size,
      playAsMinimizer)

    board[r][c] = EMPTY

    if maximizing then
      if val > best then best = val end
      if best > alpha then alpha = best end
    else
      if val < best then best = val end
      if best < beta then beta = best end
    end

    if beta <= alpha then
      return best
    end
  end

  return best
end


local function getBestMove(board, size, minPlayer)
  local bestScore = minPlayer and 1000 or -1000
  local bestMove  = nil

  for _, move in ipairs(availableMoves(board, size)) do
    local r, c = move[1], move[2]
    if minPlayer then
      board[r][c] = MIN_PLAYER
    else
      board[r][c] = MAX_PLAYER
    end

    local maximizing = not minPlayer

    local score = minimax(board, 0, maximizing, -1000, 1000, size, minPlayer)

    board[r][c] = EMPTY

    if minPlayer then
      if score < bestScore then
        bestScore = score
        bestMove  = { r, c }
      end
    else
      if score > bestScore then
        bestScore = score
        bestMove  = { r, c }
      end
    end
  end

  return bestMove
end

local function changeBoardPieceStates(boardPieces, isDisabled)
  for _, b in ipairs(boardPieces) do
    b.IsDisabled = isDisabled
  end
end

local function makeComputerMove()
  PLAYER = "O"

  local bestMove = getBestMove(BOARD, SIZE)
  local bestRow = nil
  local bestCol = nil

  if bestMove then
    bestRow = bestMove[1]
    bestCol = bestMove[2]
    print("Computer decided that best move is " .. bestRow .. " " .. bestCol)
  end

  if BOARD[bestRow] and bestRow and bestCol then
    if BOARD[bestRow][bestCol] == EMPTY then
      BOARD[bestRow][bestCol] = "O"
    end
  end
end

local function updateGameStatus(boardPieces, mainLabel)
  if GAME_STATUS == "draw" then
    mainLabel.String = "It's a draw!"
  elseif GAME_STATUS == "X" or GAME_STATUS == "O" then
    mainLabel.String = GAME_STATUS .. " Wins!"
  end

  if GAME_STATUS == "ongoing" then
    changeBoardPieceStates(boardPieces, false)
  end
end

local function initializeComputerPlayer(boardPieces, mainLabel)
  BOARD = resetBoard()
  mainLabel.String = "X's Turn"

  for i, b in ipairs(boardPieces) do
    b.IsDisabled = false
    changeBoardPieceStates(boardPieces, false)

    b.EventHandler = function(self)
      if self.Value == 1 then
        self.IsDisabled = true
        changeBoardPieceStates(boardPieces, true)
        local row, col = indexToRowCol(i, SIZE)

        if BOARD[row] then
          if BOARD[row][col] == EMPTY then
            BOARD[row][col] = PLAYER
          else
            changeBoardPieceStates(boardPieces, false)
            return
          end
        end

        if PLAYER == "X" then
          mainLabel.String = "O's Turn"
          makeComputerMove()
        end

        mainLabel.String = "X's Turn"
        PLAYER = "X"

        drawBoardState(boardPieces)

        GAME_STATUS = checkWin(BOARD, SIZE)
        updateGameStatus(boardPieces, mainLabel)
      end
    end
  end
end

local function startApp(onePlayer, twoPlayer, startGame, boardPieces)
  BOARD = resetBoard()
  PLAYER = "X"
  GAME_STATUS = "initialized"
  drawBoardState(boardPieces)
  onePlayer.Value = 0
  twoPlayer.Value = 0
  onePlayer.IsDisabled = false
  twoPlayer.IsDisabled = false
  startGame.IsDisabled = true
  changeBoardPieceStates(boardPieces, true)
end

local function initializeTwoPlayer(boardPieces, mainLabel)
  BOARD = resetBoard()
  mainLabel.String = "X's Turn"

  for i, b in ipairs(boardPieces) do
    b.IsDisabled = false
    changeBoardPieceStates(boardPieces, false)

    b.EventHandler = function(self)
      if self.Value == 1 then
        self.IsDisabled = true
        changeBoardPieceStates(boardPieces, true)
        local row, col = indexToRowCol(i, SIZE)
        if BOARD[row] then
          if BOARD[row][col] == EMPTY then
            BOARD[row][col] = PLAYER
          else
            changeBoardPieceStates(boardPieces, false)
            return
          end
        end

        if PLAYER == "X" then
          mainLabel.String = "O's Turn"
          PLAYER = "O"
        else
          mainLabel.String = "X's Turn"
          PLAYER = "X"
        end

        drawBoardState(boardPieces)

        GAME_STATUS = checkWin(BOARD, SIZE)
        updateGameStatus(boardPieces, mainLabel)
      end
    end
  end
end

if Controls then
  local OnePlayer = Controls.OnePlayer
  local TwoPlayer = Controls.TwoPlayer
  local StartGame = Controls.StartGame
  local MainLabel = Controls["TicTacToe"]
  local BoardPieces = {}

  MainLabel.String = "Tic-Tac-Toe"

  for row = 0, 2 do
    for col = 0, 2 do
      local name = string.format("Cell%d%d", row, col)
      table.insert(BoardPieces, Controls[name])
    end
  end

  startApp(OnePlayer, TwoPlayer, StartGame, BoardPieces)

  OnePlayer.EventHandler = function(self)
    if TwoPlayer.Value == 1 then
      TwoPlayer.Value = 0
    end

    self.Value = 1
    MODE = "1 Player"
    StartGame.IsDisabled = false
  end

  TwoPlayer.EventHandler = function(self)
    if OnePlayer.Value == 1 then
      OnePlayer.Value = 0
    end

    self.Value = 1
    MODE = "2 Player"
    StartGame.IsDisabled = false
  end

  StartGame.EventHandler = function(self)
    if self.Value == 1 and GAME_STATUS == "initialized" then
      self.Legend = "Reset"
      GAME_STATUS = "ongoing"
      TwoPlayer.IsDisabled = true
      OnePlayer.IsDisabled = true

      if MODE == "1 Player" then
        initializeComputerPlayer(BoardPieces, MainLabel)
      else
        initializeTwoPlayer(BoardPieces, MainLabel)
      end
    elseif self.Value == 1 and GAME_STATUS ~= "initialized" then
      self.Legend = "Start"
      MainLabel.String = "Tic-Tac-Toe"
      startApp(OnePlayer, TwoPlayer, StartGame, BoardPieces)
    end
  end
end
